;Shorter Example

;		AREA myData, DATA, READONLY ; Define a read only data section
;arr    	DCD 0xA8, 0x14, 0x24, 0x32, 0x02, 0xFF
;		AREA myDataRW, DATA, READWRITE ; Define a read write data section
;varx    DCD 0 
;vary    DCD 0
;varc	DCB 0
;vari	DCD 0
;varb	DCD 0


;Longer Example
		AREA myData, DATA, READONLY ; Define a read only data section
arr    	DCD 0xA1, 0x15, 0x32, 0x27, 0x32, 0x14, 0xA0, 0x13, 0xA2, 0x11, 0x07, 0x32, 0x14, 0xA0, 0x11, 0xA3, 0x11, 0x27, 0x14, 0x07, 0xA0, 0x11,
			0xA4, 0x14, 0x33, 0x27, 0x13, 0xA0, 0x11, 0xA5, 0x14, 0x03, 0x33, 0x04 , 0x13, 0xFF
		AREA myDataRW, DATA, READWRITE ; Define a read write data section
varx    DCD 0 
vary    DCD 0
varc	DCB 0
vari	DCD 0
varb	DCD 0



	AREA |.text|, CODE, READONLY
	THUMB
	EXPORT __main
	EXPORT SysTick_Handler
	
;REG DEFINITIONS
STCTRL		EQU	0xE000E010 ;CONTROL AND STATUS REG ADDR
STRELOAD	EQU	0xE000E014 ;RELOAD VALUE REG ADDR
STCURRENT	EQU	0xE000E018 ;CURRENT VALUE REG ADDR
SCREEN_BASE EQU 0x20001000 ;CANVAS START ADDR
WIDTH       EQU 32 ;CANVAS WIDTH 32 PX
HEIGHT      EQU 8 ; CANVAS HEIGHT 8 PX

RELOAD_VAL EQU 0x0098967F ;RELOAD VALUE FOR 1 SECOND AT 10MHz->(1 SEC * 10000000 HZ) -1 = 9999999D = 0x98967F HEX

	
__main
	BL SysTickRetimer ;HELPER FUNC TO SET STRELOAD AND CLEAR STCURRENT
	BL SysTickEnable ;HELPER FUNC TO ENABLE SYSTICK AND INTERRUPTS
	CPSIE I;CHANGE PROC STATE TO ENABLE INTRRUPT
	

MainLoop
	;IF NEW DATA IS AVAILABLE (varb == 1)
	LDR R0, =varb ;LOAD DATA FLAG
	LDR R1, [R0] ;READ VALUE OF FLAG
	CMP R1, #1 ;COMPARE VARB==1
	BNE MainLoop ;IF FLAG IS NOT 1 BRANCH
	BL Process ;CALL PROCESS FOR NEW DATA
	
	LDR R0, =varb ;LOAD FLAG AGAIN
	MOVS R1, #0 ;MOV 0 FOR PREPARING RESET FLAG
	STR R1, [R0] ;CLEAR FLAG(VARB)
	
	B MainLoop ;LOOP BACK TO WAIT FOR NEXT INTERRPT
	

SysTick_Handler PROC
	LDR R0, =vari ;LOAD INDEX TO R0
	LDR R1, [R0]     ; R1 = CURRENT IDEX
	PUSH {R1}        ; PUSH INDEX TO STACK
	LDR R0, =arr     ; R0 =ARR[0]
	LSLS R1, R1, #2  ; R1 = OFFSET (INDEX*4)
	ADDS R0, R0, R1  ; GET ELEMENT'S ADDR (OFFSET + BASE)
	LDR R1, [R0]     ; LOAD VALOUE FROM ARR
	MOVS R0, R1      ; MOVE VAL TO R0
	POP {R1}         ; RESTORE INDEX TO R1

	CMP R0, #0xFF    ; COMPARE LOADED VALUE WITH 0xFF WHICH IS TERMINATOR VALUE
	BEQ EndHandler ;IF EQUAL BRANCH END
	
	
	PUSH {R0, R1} ;SAVE R0 AND R1 IN STACK
	LDR R0, =varb ; LOAD FLAG TO R0
	MOVS R1, #1 ; MOVE 1 IN R1
	STR R1, [R0] ; SET FLAG TO 1
	POP {R0, R1} ;RESTORE R0 AND R1 FROM STACK TO REGS
	
	ADDS R1, R1, #1  ; INDEX = INDEX +1
	LDR R0, =vari ;LOAD ADDR OF INDX
	STR R1, [R0] ; STORE CHANGED INDEX
	
EndHandler
	BX LR;RETURN FROM INTERRUPT
	ENDP
		
SysTickDisable PROC ;HELPER FUNC FOR SYSTICK TIMER
	PUSH {R0, R1, LR} ;SAVE REGS AND LR
	LDR R0, =STCTRL ;LOAD STCTRL
	MOVS R1, #0 ;MOVE 0 TO R1 TO CLEAR ENABLE
	STR R1, [R0] ;WRITE REG TO STOP TIMER
	POP {R0, R1, PC} ;RESTROE REGS AND RETURN
	ENDP
		
SysTickEnable PROC ;HELPER FUNC TO ENABLE SYSTICK TIMER
	PUSH {R0, R1, LR} ;SAVE REGS AND LR
	LDR R0, =STCTRL ;LOAD STCTRL
	MOVS R1, #7 ;MOVE BINARY 111 TO ENABLE (TIMER, INTERRUPT, CLOCK)
	STR R1, [R0] ;WRITE REG TO START TIMER
	POP {R0, R1, PC} ;RESTROE REGS AND RETURN
	ENDP
	
SysTickRetimer PROC ;HELPER FUNC TO SET RELOAD AND CLEAR CURRENT
	PUSH {R0, R1, LR} ;SAVE REGS AND LR
	LDR R0, =STRELOAD; LOAD SYSTICK RELOAD REG
	LDR R1, =RELOAD_VAL ;LOAD CALCULATED RELOAD_VAL
	STR R1, [R0]; STRE RELOAD_VAL INTO RELOAD REG
	
	LDR R0, =STCURRENT ;LOAD STCURRENT REG
	MOVS R1, #0 ;MOVE 0 TO R1 FOR CLEAR INSIDE
	STR R1, [R0] ;WRITE CONFIG TO START TIMER
	
	POP {R0, R1, PC} ;RESTORE REGS AND RETURN
	ENDP


Process PROC
	PUSH {R0, R1, LR} ;STORE REG IN STACK
	LDR R0, =vari ;LOAD INDEX ADDR
	LDR R1, [R0] ;LOAD INDEX VALUE
	SUBS R1, R1, #1  ;INDEX = INDEX -1
	
	LDR R0, =arr ;LOAD ARR[0]
	LSLS R1, R1, #2 ;OFFSET = INDX*4
	ADDS R0, R0, R1 ;CALC ELEMENT'S ADDR
	LDR R1, [R0] ;LOAD INPUT VAL IN R1
	
	MOVS R0, R1;MOVE INPUT TO R0 FOR REQUESTED CHANGES
	LSRS R0, R0, #4 ;SHIFT RIGHT 4 FOR SEPARATING UPPER BITS
	CMP R0, #0xA ;COMPARE UPPER BITS WITH COLOR
	BEQ SetColor ;IF EQUAL, BRANCH SET COLOR
	
	B DoMovement ;ELSE BRANCH MOVE
	
SetColor 
	MOVS R0, #0x0F;FOR MASKING MOVE 0x0F TO R0
	ANDS R1, R1, R0;MASK UPPER BITS TO GET COLOR
	
	MOVS R0, R1 ;COPY LOWER 4 BIT TO R0
	LSLS R0, R0, #4 ;SHIFT LEFT R0 BY 4 (0x20)
	ORRS R1, R1, R0 ; 0x20 OR 0x02 = 0x22
	
	LDR R0, =varc ;LOAD ADR OF COLOR
	STRB R1, [R0] ;STORE NEW COLOR BYTE
	B EndProcess ;BRANCH END PROCESS
	
DoMovement
	MOVS R0, #0x0F ;FOR MASKING MOVE 0x0F TO R0
	ANDS R0, R1, R0 ;MASK TO GET LENGTH 
	CMP R0, #0 ;COMPARE LENGHT WITH 0
	BEQ EndProcess ;IF LEN == 0 BRANCH END PROCESS
	PUSH {R0}       ; ELSE PUSH LENGTH TO STACK
	LSRS R1, R1, #4 ; SHIFT RIGHT BY 4 FOR DIRECTION
	
PaintLoop
	BL MoveCursor ;BRANCH HORIZONTAL AND VERTICAL POSITIONS
	BL PaintPixel ;BRANCH PAINT MEMORY
	
	POP {R0} ;POP LENGTH
	SUBS R0, R0, #1 ; LENGTH= LENGTH -1
	CMP R0, #0 ;COMPARE LENGTH AND 0
	BEQ EndProcess  ; If EQUAL BRANCH END PROCESS
	
	PUSH {R0}       ;ELSE PUSH UPDATED LENGTH TO STACK
	B PaintLoop     ;BRANCH PAINT LOOP
	
EndProcess
	POP {R0, R1, PC}; RESTORE REGS AND RETURN
	ENDP 
		
MoveCursor PROC
	PUSH {R0,R1,LR} ;SAVE REGS
	CMP R1, #0 ;COMPARE DIRECTION AND 0
	BEQ GoUp ;IF 0 GO UP
	CMP R1, #1 ;COPMARE DIRECTION AND 1
	BEQ GoRight ;IF 1 GO RIGHT
	CMP R1,#2 ;COMPARE DIRECTION AND 2
	BEQ GoDown ;IF 2 GO DOWN
	CMP R1, #3 ;COMPARE DIRECTION AND 3
	BEQ GoLeft ;IF 3 GO LEFT
	B ExitMove ;ELSE BRANCH EXIT MOVE
	
GoUp 
	LDR R0, =vary; LOAD VERTICAL ADDR
	LDR R1, [R0] ;LOAD VARY VALUE
	SUBS R1, R1, #1 ;VARY = VARY -1
	CMP R1, #0xFF; COMPARE 0xFF (0-1)
	BEQ ExitMove  ;IF EQUAL EXIT
	STR R1, [R0] ;ELSE STORE NEW VARY
	B ExitMove ;BRANCH EXIT
	
GoDown
	LDR R0, =vary ;LOAD VERTICAL ADDR
	LDR R1, [R0] ;LOAD VARY VALUE
	ADDS R1, R1, #1 ;VARY = VARY +1
	CMP R1, #HEIGHT ;COMPARE UPPER LIMIT
	BEQ ExitMove ; IF EQUAL EXIT
	STR R1, [R0] ;ELSE STORE NEW VARY
	B ExitMove ;BRANCH EXIT
	
GoLeft 
	LDR R0, =varx ;LOAD HORIZONTAL ADDR
	LDR R1, [R0] ;LOAD VARX VLAUE
	SUBS R1, R1, #1 ; VARX = VARX-1
	CMP R1, #0xFF; COMPARE 0xFF (0-1)
	BEQ ExitMove ;IF EQUAL EXIT
	STR R1, [R0] ;ELSE STORE NEW VARX
	B ExitMove ;BRANCH EXIT
	
GoRight 
	LDR R0, =varx ;LOAD HORIZONTAL ADDR
	LDR R1, [R0] ;LOAD VARX VLAUE
	ADDS R1, R1, #1 ; VARX = VARX+1
	CMP R1, #WIDTH ;COMPARE WIDTH LIMIT
	BEQ ExitMove ;IF REACH LIMIT, BRANCH EXIT
	STR R1, [R0] ;ELSE STORE NEW VARX
	B ExitMove ;BRANCH EXIT
	
ExitMove
	POP {R0, R1, PC} ;RESTORE REGS AND RETURN
	ENDP
		
PaintPixel PROC
	PUSH {R0, R1, LR} ;STORE REGS IN STACK
	
	LDR R0, =vary ;LOAD VERTICAL ADDR
	LDR R0, [R0] ;LOAD VERTICAL VALUE
	LSLS R0, R0, #5 ; VARY = VARY*32 (OFFSET)
	
	LDR R1, =varx ;LOAD HORIZONTAL ADDR
	LDR R1, [R1] ;LOAD HORIZONTAL VALUE
	ADDS R0, R0, R1 ;R0 = VARY*32 + VARX (OFFSET + VARX)
	
	LDR R1,=SCREEN_BASE ;LOAD SCREEN_BASE ADDR
	ADDS R0, R0, R1 ;BASE + OFFSET TO GET PX ADDR
	
	LDR R1, =varc ;LOAD CURRENT COLOR ADDR
	LDRB R1, [R1] ;LOAD COLOR VALUE
	STRB R1, [R0]  ;PAINT BYTE OF COLOR
	
	POP {R0, R1, PC};RESTORE REGS AND RETURN
	ENDP
	
		
	END
		
